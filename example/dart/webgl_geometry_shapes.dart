/*
 * Based on r72-dev
 */

import 'dart:html' hide Path;
import 'dart:math' as math;
import 'dart:async';
import 'package:three/three.dart';
import 'package:three/extras/image_utils.dart' as image_utils;

PerspectiveCamera camera;
Scene scene;
WebGLRenderer renderer;

num windowHalfX, windowHalfY;
num mouseX = 0;
num mouseXOnMouseDown = 0;

List<StreamSubscription> mouseEvts = [];

double targetRotation = 0.0;
double targetRotationOnMouseDown = 0.0;

Group group;

void main() {
  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  init();
  animate(0);
}

void init() {
  scene = new Scene();

  camera = new PerspectiveCamera(50.0, window.innerWidth / window.innerHeight, 1.0, 1000.0)
    ..position.setValues(0.0, 150.0, 500.0);

  scene.add(camera);

  camera.add(new PointLight(0xffffff, intensity: 0.8));

  group = new Group()
    ..position.y = 50.0;
  scene.add(group);

  var texture = image_utils.loadTexture('textures/UV_Grid_Sm.jpg');
  texture.wrapS = texture.wrapT = RepeatWrapping;
  texture.repeat.setValues(0.008, 0.008);

  void addShape(Shape shape, num color, x, y, z, rx, ry, rz, s,
      {int amount: 8, bool bevelEnabled: true, int bevelSegments: 2, int steps: 2, double bevelSize: 1.0, double bevelThickness: 1.0}) {
    x = x.toDouble(); y = y.toDouble(); z = z.toDouble();
    rx = rx.toDouble(); ry = ry.toDouble(); rz = rz.toDouble();
    s = s.toDouble();

    var points = shape.createPointsGeometry();
    var spacedPoints = shape.createSpacedPointsGeometry(50);

    // flat shape with texture
    // note: default UVs generated by ShapeGemoetry are simply the x- and y-coordinates of the vertices

    var geometry = new ShapeGeometry(shape);

    var mesh = new Mesh(geometry, new MeshPhongMaterial(side: DoubleSide, map: texture))
      ..position.setValues(x, y, z - 175.0)
      ..rotation.setValues(rx, ry, rz )
      ..scale.splat(s);
    group.add(mesh);

    // flat shape

    group.add(new Mesh(new ShapeGeometry(shape), new MeshPhongMaterial(color: color, side: DoubleSide))
     ..position.setValues(x, y, z - 125.0)
     ..rotation.setValues(rx, ry, rz)
     ..scale.splat(s));

    // 3d shape
    group.add(new Mesh(new ExtrudeGeometry(shape, amount: amount, bevelEnabled: bevelEnabled, bevelSegments: bevelSegments, steps: steps,
        bevelSize: bevelSize, bevelThickness: bevelThickness), new MeshPhongMaterial(color: color))
      ..position.setValues(x, y, z - 75.0)
      ..rotation.setValues(rx, ry, rz)
      ..scale.splat(s));

    // solid line
    group.add(new Line(points, new LineBasicMaterial(color: color, linewidth: 3.0))
      ..position.setValues(x, y, z - 25.0)
      ..rotation.setValues(rx, ry, rz)
      ..scale.splat(s));

    // vertices from real points
    group.add(new PointCloud(points.clone(), new PointCloudMaterial(color: color, size: 4.0))
     ..position.setValues(x, y, z + 25.0)
     ..rotation.setValues(rx, ry, rz)
     ..scale.splat(s));

    // line from equidistance sampled points
    group.add(new Line(spacedPoints, new LineBasicMaterial(color: color, linewidth: 3.0))
      ..position.setValues(x, y, z + 75.0)
      ..rotation.setValues(rx, ry, rz)
      ..scale.splat(s));

    // equidistance sampled points
    group.add(new PointCloud(spacedPoints.clone(), new PointCloudMaterial(color: color, size: 4.0))
      ..position.setValues(x, y, z + 125.0)
      ..rotation.setValues(rx, ry, rz)
      ..scale.splat(s));
  }

  // California
  var californiaPts = [
    new Vector2 (610.0, 320.0),
    new Vector2 (450.0, 300.0),
    new Vector2 (392.0, 392.0),
    new Vector2 (266.0, 438.0),
    new Vector2 (190.0, 570.0),
    new Vector2 (190.0, 600.0),
    new Vector2 (160.0, 620.0),
    new Vector2 (160.0, 650.0),
    new Vector2 (180.0, 640.0),
    new Vector2 (165.0, 680.0),
    new Vector2 (150.0, 670.0),
    new Vector2 (90.0, 737.0),
    new Vector2 (80.0, 795.0),
    new Vector2 (50.0, 835.0),
    new Vector2 (64.0, 870.0),
    new Vector2 (60.0, 945.0),
    new Vector2 (300.0, 945.0),
    new Vector2 (300.0, 743.0),
    new Vector2 (600.0, 473.0),
    new Vector2 (626.0, 425.0),
    new Vector2 (600.0, 370.0),
    new Vector2 (610.0, 320.0)
  ].map((point) => point.scale(0.25)).toList();

  var californiaShape = new Shape(californiaPts);

  // Triangle
  var triangleShape = new Shape()
    ..moveTo(80.0, 20.0)
    ..lineTo(40.0, 80.0)
    ..lineTo(120.0, 80.0)
    ..lineTo(80.0, 20.0); // close path

  // Heart
  var x = 0.0, y = 0.0;
  var heartShape = new Shape() // From http://blog.burlock.org/html5/130-paths
    ..moveTo(x + 25, y + 25)
    ..bezierCurveTo(x + 25.0, y + 25.0, x + 20.0, y, x, y)
    ..bezierCurveTo(x - 30.0, y, x - 30.0, y + 35.0, x - 30.0, y + 35.0)
    ..bezierCurveTo(x - 30.0, y + 55.0, x - 10.0, y + 77.0, x + 25.0, y + 95.0)
    ..bezierCurveTo(x + 60.0, y + 77.0, x + 80.0, y + 55.0, x + 80.0, y + 35.0)
    ..bezierCurveTo(x + 80.0, y + 35.0, x + 80.0, y, x + 50.0, y)
    ..bezierCurveTo(x + 35.0, y, x + 25.0, y + 25.0, x + 25.0, y + 25.0);

  // Square
  var sqLength = 80.0;
  var squareShape = new Shape()
    ..moveTo(0.0, 0.0)
    ..lineTo(0.0, sqLength)
    ..lineTo(sqLength, sqLength)
    ..lineTo(sqLength, 0.0)
    ..lineTo(0.0, 0.0);

  // Rectangle
  var rectLength = 120.0, rectWidth = 40.0;
  var rectShape = new Shape()
    ..moveTo(0.0, 0.0)
    ..lineTo(0.0, rectWidth)
    ..lineTo(rectLength, rectWidth)
    ..lineTo(rectLength, 0.0)
    ..lineTo(0.0, 0.0);

  // Rounded rectangle
  var roundedRectShape = new Shape();

  ((Shape ctx, x, y, width, height, radius) {
    ctx.moveTo(x, y + radius);
    ctx.lineTo(x, y + height - radius);
    ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
    ctx.lineTo(x + width - radius, y + height) ;
    ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
    ctx.lineTo(x + width, y + radius);
    ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
    ctx.lineTo(x + radius, y);
    ctx.quadraticCurveTo(x, y, x, y + radius);
  })(roundedRectShape, 0.0, 0.0, 50.0, 50.0, 20.0);

  // Track
  var trackShape = new Shape()
    ..moveTo(40.0, 40.0)
    ..lineTo(40.0, 160.0)
    ..absarc(60.0, 160.0, 20.0, math.PI, 0, true)
    ..lineTo(80.0, 40.0)
    ..absarc(60.0, 40.0, 20.0, 2 * math.PI, math.PI, true);

  // Circle
  var circleRadius = 40.0;
  var circleShape = new Shape()
    ..moveTo(0.0, circleRadius)
    ..quadraticCurveTo(circleRadius, circleRadius, circleRadius, 0)
    ..quadraticCurveTo(circleRadius, -circleRadius, 0, -circleRadius)
    ..quadraticCurveTo(-circleRadius, -circleRadius, -circleRadius, 0)
    ..quadraticCurveTo(-circleRadius, circleRadius, 0, circleRadius);

  // Fish
  x = y = 0.0;
  var fishShape = new Shape()
    ..moveTo(x, y)
    ..quadraticCurveTo(x + 50.0, y - 80.0, x + 90.0, y - 10.0)
    ..quadraticCurveTo(x + 100.0, y - 10.0, x + 115.0, y - 40.0)
    ..quadraticCurveTo(x + 115.0, y, x + 115.0, y + 40.0)
    ..quadraticCurveTo(x + 100.0, y + 10.0, x + 90.0, y + 10.0)
    ..quadraticCurveTo(x + 50.0, y + 80.0, x, y);

  // Arc circle
  var arcShape = new Shape()
    ..moveTo(50.0, 10.0)
    ..absarc(10.0, 10.0, 40.0, 0.0, math.PI * 2, false);
  var holePath = new Path()
    ..moveTo(20.0, 10.0)
    ..absarc(10.0, 10.0, 10.0, 0.0, math.PI * 2, true);
  arcShape.holes.add(holePath);

  // Smiley
  var smileyShape = new Shape()
    ..moveTo(80.0, 40.0)
    ..absarc(40.0, 40.0, 40.0, 0.0, math.PI * 2, false);
  var smileyEye1Path = new Path()
    ..moveTo(35.0, 20.0)
    ..absellipse(25.0, 20.0, 10.0, 10.0, 0.0, math.PI * 2, true);
  smileyShape.holes.add(smileyEye1Path);
  var smileyEye2Path = new Path()
    ..moveTo(65.0, 20.0)
    ..absarc(55.0, 20.0, 10.0, 0.0, math.PI * 2, true);
  smileyShape.holes.add(smileyEye2Path);
  var smileyMouthPath = new Path()
    ..moveTo(20.0, 40.0)
    ..quadraticCurveTo(40.0, 60.0, 60.0, 40.0)
    ..bezierCurveTo(70.0, 45.0, 70.0, 50.0, 60.0, 60.0)
    ..quadraticCurveTo(40.0, 80.0, 20.0, 60.0)
    ..quadraticCurveTo(5.0, 50.0, 20.0, 40.0);
  smileyShape.holes.add(smileyMouthPath);

  // Spline shape
  var splinepts = [
    new Vector2(70.0, 20.0),
    new Vector2(80.0, 90.0),
    new Vector2(-30.0, 70.0),
    new Vector2(0.0, 0.0)
  ];
  var splineShape = new Shape()
    ..moveTo(0.0, 0.0)
    ..splineThru(splinepts);

  // addShape(shape, color, x, y, z, rx, ry, rz, s);

  addShape(californiaShape,  0xf08000, -300, -100, 0, 0, 0, 0, 1);
  addShape(triangleShape,    0x8080f0, -180,    0, 0, 0, 0, 0, 1);
  addShape(roundedRectShape, 0x008000, -150,  150, 0, 0, 0, 0, 1);
  addShape(trackShape,       0x008080,  200, -100, 0, 0, 0, 0, 1);
  addShape(squareShape,      0x0040f0,  150,  100, 0, 0, 0, 0, 1);
  addShape(heartShape,       0xf00000,   60,  100, 0, 0, 0, math.PI, 1);
  addShape(circleShape,      0x00f000,  120,  250, 0, 0, 0, 0, 1);
  addShape(fishShape,        0x404040,  -60,  200, 0, 0, 0, 0, 1);
  addShape(smileyShape,      0xf000f0, -200,  250, 0, 0, 0, math.PI, 1);
  addShape(arcShape,         0x804000,  150,    0, 0, 0, 0, 0, 1);
  addShape(splineShape,      0x808080,  -50, -100, 0, 0, 0, 0, 1);

  //

  renderer = new WebGLRenderer(antialias: true)
    ..setClearColor(new Color(0xf0f0f0))
    ..setPixelRatio(window.devicePixelRatio)
    ..setSize(window.innerWidth, window.innerHeight);

  document.body.append(renderer.domElement);

  mouseEvts = [
      document.onMouseDown.listen(onDocumentMouseDown),
      document.onTouchStart.listen(onDocumentTouchStart),
      document.onTouchMove.listen(onDocumentTouchMove)];

  window.onResize.listen(onWindowResize);
}

void onWindowResize(_) {
  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
}

void cancelMouseEvts() {
  mouseEvts.forEach((s) => s.cancel());
}

void onDocumentMouseDown(MouseEvent event) {
  event.preventDefault();

  mouseEvts = [
      document.onMouseMove.listen(onDocumentMouseMove),
      document.onMouseUp.listen(onDocumentMouseUp),
      document.onMouseOut.listen(onDocumentMouseOut)];

  mouseXOnMouseDown = event.client.x - windowHalfX;
  targetRotationOnMouseDown = targetRotation;
}

void onDocumentMouseMove(MouseEvent event) {
  mouseX = event.client.x - windowHalfX;
  targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.02;
}

void onDocumentMouseUp(_) {
  cancelMouseEvts();
}

void onDocumentMouseOut(_) {
  cancelMouseEvts();
}

void onDocumentTouchStart(TouchEvent event) {
  if (event.touches.length == 1) {
    event.preventDefault();

    mouseXOnMouseDown = event.touches[0].page.x - windowHalfX;
    targetRotationOnMouseDown = targetRotation;
  }
}

void onDocumentTouchMove(TouchEvent event) {
  if (event.touches.length == 1) {
    event.preventDefault();

    mouseX = event.touches[0].page.x - windowHalfX;
    targetRotation = targetRotationOnMouseDown + (mouseX - mouseXOnMouseDown) * 0.05;
  }
}

void animate(num time) {
  window.requestAnimationFrame(animate);
  render();
}

void render() {
  group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
  renderer.render(scene, camera);
}
